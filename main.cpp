/**
 * Project: PV Curve Tracer Board
 * File: main.cpp
 * Author: Matthew Yu (2021).
 * Organization: UT Solar Vehicles Team
 * Created on: 05/29/21
 * Last Modified: 06/27/21
 * File Description: This file describes the operation and execution of the
 * PV Curve Tracer board for the UT LHR Solar Vehicles Team. 
 * L432KC Pinout:
 * https://os.mbed.com/media/uploads/bcostm/nucleo_l432kc_2017_10_09.png
 * Note: The following pins must be reserved during STLink debugging:
 * - PA11 | D10 | USP_DM
 * - PA12 | D2  | USB_DP
 * - PA13 | N/A | USB_NOE
 * - PC14 | D7  | RCC_OSC32_IN
 * - PC15 | D8  | RCC_OSC32_OUT
 * - PA14 | N/A | SYS_JTCK_SWCLK
 * - PA15 | N/A | SYS_JTDI
 * - PB3  | D13 | SYS_JTDO_SW0
 * - PA13 | N/A | SYS_JTMS_SWDIO
 * - PB4  | D12 | SYS_JTRST
 * - PB7  | D4  | SYS_PVD_IN
 * - PA0  | A0  | SYS_WKUP1
 * - PA2  | A7  | SYS_WKUP4
 * L432KC specific.
 */


/** Includes. */
#include "mbed.h"
#include <chrono>
#include <cstdio>
#include "Errors.h"
#include "ComIds.h"
#include "Fifo.cpp"


/** Defines. */
#define CAN_TX D2
#define CAN_RX D9 /* Errata. Should be D10. */
#define ADC_CURRENT A6
#define ADC_VOLTAGE A0
#define DAC_CONTROL A3
#define LED_HEARTBEAT D3
#define LED_SCANNING D0
#define LED_ERROR D1
#define QUEUE_SIZE 100
#define VOLTAGE_IDX 0
#define CURRENT_IDX 1
#define IRRADIANCE_IDX 2
#define TEMPERATURE_IDX 3


/** Struct definitions. */
/** The profile struct is used for test execution and is generated by the user. */
struct profile {
    bool complete;              /* Whether the profile is valid and can be executed. */

    /* User defined variables. */
    enum regime {               /* Test regime. Affects the scaling of the ADC readings. */
        NO_REGIME, 
        CELL, 
        MODULE, 
        SUBARRAY, 
        RESERVED1, 
        RESERVED2, 
        RESERVED3, 
        RESERVED4
    } testRegime;
    float voltageStart;         /* Starting voltage, in V (0 - 3.3 V). */
    float voltageEnd;           /* Ending voltage, in V (0 - 3.3 V). */
    float voltageResolution;    /* Voltage resolution, in V (0 - 1 V). */

    /* Derivative variables. */
    uint32_t sampleId;          /* Current sampleId. Only modifiable by sample() during an experiment. */
    uint32_t numSamples;        /* Number of samples in the experiment. */
};
/** The result struct is used by information sources (i.e. sensors or CAN/serial
    messages from sensors) to format data posting to the user. */
struct result {
    bool isProcessed;           /* if true, the data can be scratched. */
    enum type {                 /* Result source. */
        NONE, 
        VOLTAGE, 
        CURRENT, 
        IRRADIANCE, 
        TEMPERATURE, 
        RESERVED1, 
        RESERVED2,
        RESERVED3
    } sensorType;
    uint32_t sampleId;          /* Sample ID of result. */
    float value;                /* Value of the result. */
};


/** Object declarations. */
/** LEDs. */
DigitalOut ledHeartbeat(D3);
DigitalOut ledScanning(LED_SCANNING);
DigitalOut ledCanTx(CAN_TX);
DigitalOut ledCanRx(CAN_RX);
DigitalOut ledError(LED_ERROR);
/** Tickers. */
LowPowerTicker tickHeartbeat;
Ticker tickSample;
/** Sensors. */
AnalogIn sensorVoltage(ADC_VOLTAGE);
AnalogIn sensorCurrent(ADC_CURRENT);
/** DAC. */
AnalogOut controlDac(DAC_CONTROL);
/** Serial. */
static BufferedSerial serialPort(USBTX, USBRX);
/** Data structures. */
struct profile testProfile = {
    .complete = false,
    .testRegime = profile::NO_REGIME,
    .sampleId = 0
};
struct result results[4] = {
    {
        .isProcessed = false,
        .sensorType = result::VOLTAGE,
        .sampleId = 0,
        .value = 0.0
    }, {
        .isProcessed = false,
        .sensorType = result::CURRENT,
        .sampleId = 0,
        .value = 0.0
    }, {
        .isProcessed = false,
        .sensorType = result::IRRADIANCE,
        .sampleId = 0,
        .value = 0.0
    }, {
        .isProcessed = false,
        .sensorType = result::TEMPERATURE,
        .sampleId = 0,
        .value = 0.0
    },
};
uint16_t lastMsgId = INVALID_MSG_ID;
uint16_t lastErrorCode = ERR_NONE;

/** Processing structures. */
static Thread threadProcessing, threadTesting;
static EventQueue queue(QUEUE_SIZE * EVENTS_EVENT_SIZE);


/** Function definitions. */

/** Indicator Management. */
/** Cycles an LED numCycles time, for a delayMs toggle period. */
static void cycleLed(DigitalOut *dout, uint8_t numCycles, std::chrono::milliseconds delayMs);
/** Toggles the hearbeat. */
static void heartbeat(void);

/** Experiment Management. */
/** Samples the onboard sensors and fills in a results reference. */
static void sampleOnboardSensors(uint32_t sampleId, struct result *resultVoltage, struct result *resultCurrent);
static void performTest(void);

/** Inbound Message Processing. */
static void pollSerial(void);
static uint16_t checkProfile(char *buf, struct profile *profile);

/** Outbound Message Processing. */
void processResult(uint16_t msgId, struct result *result);
void processError(uint16_t msgId, uint16_t errorCode);

/** Error Handling. */
static void errorLoop(void);

/** Function implementations. */
int main() {
    /* Setup serial comm. */
    serialPort.set_baud(9600);
    serialPort.set_format(
        8,                      /* bits */ 
        BufferedSerial::None,   /* parity */ 
        1                       /* stop bit */ 
    );

    /* Cycle LEDs. */
    cycleLed(&ledHeartbeat, 4, std::chrono::milliseconds(100));
    cycleLed(&ledScanning, 4, std::chrono::milliseconds(100));
    cycleLed(&ledCanTx, 4, std::chrono::milliseconds(100));
    cycleLed(&ledCanRx, 4, std::chrono::milliseconds(100));
    cycleLed(&ledError, 4, std::chrono::milliseconds(100));

    /* Set a heartbeat toggle for 0.5 Hz. */
    tickHeartbeat.attach(&heartbeat, chrono::milliseconds(1000));

    /* Start threads for processing data and capturing. */
    threadProcessing.start(callback(&queue, &EventQueue::dispatch_forever));
    threadTesting.start(performTest);

    /* Main thread looks for messages. */
    uint32_t i = 0;
    while (true) {
        if (i++ == 3) { 
            uint16_t errCode = checkProfile(nullptr, &testProfile); 
            testProfile.complete = true;
            while(1);
        }
        // pollSerial();
        /* pollCan(); */
        /* pollAltSerial(); */
        ThisThread::sleep_for(chrono::milliseconds(1000));
    }
}


/** Indicator Management. */
static void heartbeat(void) { ledHeartbeat = !ledHeartbeat; }
static void cycleLed(DigitalOut *dout, uint8_t numCycles, std::chrono::milliseconds delayMs) {
    for (uint8_t i = 0; i < numCycles; ++i) {
        *dout = 1;
        ThisThread::sleep_for(delayMs);
        *dout = 0;
        ThisThread::sleep_for(delayMs);
    }
}


/** Experiment Management. */
static void sampleOnboardSensors(uint32_t sampleId, struct result *resultVoltage, struct result *resultCurrent) {
    resultVoltage->value = sensorVoltage;
    resultVoltage->sampleId = sampleId;
    resultVoltage->isProcessed = false;

    resultCurrent->value = sensorCurrent;
    resultCurrent->sampleId = sampleId;
    resultCurrent->isProcessed = false;
}
static void performTest(void) {
    while (true) {
        /* Wait for profile to begin. */
        if (testProfile.complete) {
            /* Cycle scanning LED for 3 seconds. */
            cycleLed(&ledScanning, 3, chrono::milliseconds(250));

            testProfile.sampleId = 0;
            testProfile.numSamples = (testProfile.voltageEnd - testProfile.voltageStart)/testProfile.voltageResolution;
    
            /* Turn on scanning LED and perform test. */
            ledScanning = 1;
            do {
                /* Set DAC output. Multiplied by 5x in HW. */
                controlDac = (float) testProfile.sampleId * testProfile.voltageResolution + testProfile.voltageStart;

                /* When DAC output is as expected, wait X ms for system to stabilize. */
                ThisThread::sleep_for(std::chrono::milliseconds(15)); /* TODO: make dependent on voltage step and mode. */

                /* Capture sensor data and post to queue. */
                sampleOnboardSensors(testProfile.sampleId, &results[VOLTAGE_IDX], &results[CURRENT_IDX]);
                queue.call(processResult, CRVTRCR_VOLT_MEAS, &results[VOLTAGE_IDX]);
                queue.call(processResult, CRVTRCR_CURR_MEAS, &results[CURRENT_IDX]);

                /* Idle until queue has processed the events. */
                while (!results[VOLTAGE_IDX].isProcessed || !results[CURRENT_IDX].isProcessed)
                    ThisThread::sleep_for(std::chrono::milliseconds(5));

                testProfile.sampleId++;
            } while (testProfile.sampleId < testProfile.numSamples);  

            /* Turn off scanning LED and set testProfile back to false. */      
            ledScanning = 0;
            testProfile.complete = false;
        }
        ThisThread::sleep_for(std::chrono::milliseconds(2500));
    }
}


/** Inbound Message Processing. */
static void pollSerial(void) {
    #define MAX_BUFFER_SIZE 3 * 8
    #define DATA_TRANSFER_SIZE 4
    #define PRELUDE 0xFF
    
    static char data[DATA_TRANSFER_SIZE] = { 0 };       /* Buffer for reading and peeking at data. */
    static char buffer[MAX_BUFFER_SIZE];                /* Buffer for fifo storage. */
    static Fifo fifo = Fifo(buffer, MAX_BUFFER_SIZE);   /* Fifo for message capture. 3x the largest message size, 8 bytes. */
        
    /* If there is a an opportunity to read a byte, attempt to take it. */
    if (!fifo.isFull()) {
        if (serialPort.read(data, 1)) {
            fifo.enqueue(data[0]);
        }
    }
    
    /* Peek into the FIFO for the first 3 bytes. */
    if (fifo.peek(data, DATA_TRANSFER_SIZE) == 3) {
        /* Capture and check the prelude. */
        if (data[0] != PRELUDE) {
            /* Return early after discarding the first byte. */
            char throwawayByte;
            fifo.dequeue(throwawayByte); /* TODO: assume this returns true. Otherwise an exception is needed. */
            return;
        }
        
        /* Handle data based on message ID. */
        uint16_t msgId = ((data[1] << 8) | (data[2] & 0xF0)) >> 4;
        switch (msgId) {
            case CRVTRCR_INP_PROFILE: 
                #define CRVTRCR_INP_PROFILE_NUM_BYTES 8
                if (fifo.getUsedCapacity() >= CRVTRCR_INP_PROFILE_NUM_BYTES) {
                    /* Read CRVTRCR_INP_PROFILE_NUM_BYTES chars and begin
                       parsing. */
                    char input[CRVTRCR_INP_PROFILE_NUM_BYTES] = { 0 };
                    for (uint8_t i = 0; i < CRVTRCR_INP_PROFILE_NUM_BYTES; ++i) {
                        fifo.dequeue(input[i]);
                    }

                    /* Check the profile and set it if correct. */
                    uint16_t errCode = checkProfile(input, &testProfile);
                    if (errCode) {
                        /* Invalid profile. */
                        testProfile.complete = false;
                        queue.call(processError, msgId, errCode);
                    }
                    testProfile.complete = false;
                }
                #undef CRVTRCR_INP_PROFILE_NUM_BYTES
                break;
            
            /* These should never be received. Throw an error. */
            case CRVTRCR_RESULT:
            case CRVTRCR_FAULT: 
            default:
                queue.call(processError, msgId, ERR_UNEXPECTED_MSG_ID);
                break;
        }
    }

    #undef DATA_TRANSFER_SIZE
    #undef MAX_BUFFER_SIZE
}
static uint16_t checkProfile(char *buf, struct profile *profile) {
    /* Byte 3, most significant nibble (MSN) is Test Regime Type. */
    profile->testRegime = profile::CELL; /* TODO: Replace with actual inputs. */
    if (profile->testRegime == profile::NO_REGIME || profile->testRegime >= profile::RESERVED1) {
        return ERR_INVALID_PROFILE;
    }

    /* Byte 3 LSN, 4 is Start Voltage * 1000. */
    profile->voltageStart = 0.0;
    if (profile->voltageStart < 0.0 || profile->voltageStart > 3.3) {
        return ERR_INVALID_VOLTAGE_START;
    }

    /* Byte 5, 6 MSN is End Voltage * 1000. */
    profile->voltageEnd = 0.7;
    if (profile->voltageEnd < 0.0 || profile->voltageEnd > 3.3) {
        return ERR_INVALID_VOLTAGE_END;
    }

    if (profile->voltageStart > profile->voltageEnd) {
        return ERR_INVALID_VOLTAGE_CONSISTENCY;
    }

    /* Byte 6 LSN, 7 is Voltage Resolution * 1000. */
    profile->voltageResolution = 0.05;
    if (profile->voltageResolution <= 0.0 || profile->voltageResolution > 1.0) {
        return ERR_INVALID_VOLTAGE_RESOLUTION;
    }

    return ERR_NONE;
}


/** Outbound Message Processing. */
void processResult(uint16_t msgId, struct result *result) {
    printf(
        "%02x%03x%01x%03x%05x",
        0xFF,
        msgId,
        result->sensorType,
        result->sampleId,
        (uint32_t)(result->value * 1000)
    );
    result->isProcessed = true;
}
void processError(uint16_t msgId, uint16_t errorCode) {
    printf(
        "%02x%03x%03x", 
        0xFF,
        msgId,
        errorCode
    );
}

/** Error Handling. */
static void errorLoop(void) {
    ledError = 1;
    while (true);
}
