//! This file visualizes a set of packets generated by the parser and saves it to a relevant file. It can also display data in realtime (TODO: this)
//! 
//! # Info
//! * File: visualizer.rs
//! * Author: Matthew Yu
//! * Organization: UT Solar Vehicles Team
//! * Date Created: 8/29/20
//! * Last Modified: 9/7/20

use plotters::prelude::*;
use chrono::{DateTime, Utc};

/// default to 900 pixels
const IMAGE_WIDTH:u32 = 900;
/// default to 600 pixels
const IMAGE_HEIGHT:u32 = 600;

/// visualize_packets creates an image using the plotters crate of the datasets presented in packets_sets.
/// A separate image is generated for each PacketSet.
/// The image contains four series, for current, power, temperature, and irradiance measurements.
/// 
/// # Arguments
/// 
/// * `packet_sets` - a set of PacketSets of testing regimes.
pub fn visualize(
    packet_id: i32, 
    packet_params: Vec<f32>, 
    series_current: Vec<(i32, i32)>, 
    series_power:Vec<(i32, i32)>, 
    series_temp: Vec<(i32, i32)>,
    series_irrad: Vec<(i32, i32)>
) {
    // visualize with plotters
    // generate file name
    let mut file_path: String = "img/".to_owned();
    let now: DateTime<Utc> = Utc::now();
    file_path.push_str(&format!("{}_", now));
    file_path.push_str(&packet_id.to_string());
    file_path.push_str(".png");
    // create the canvas
    let root_drawing_area = BitMapBackend::new(&file_path, (IMAGE_WIDTH, IMAGE_HEIGHT)).into_drawing_area();
    // set canvas as white
    root_drawing_area.fill(&WHITE).unwrap();
    
    // generate image name
    let mut image_name: String = "Test Regime for [".to_owned();
    image_name.push_str(&packet_params[0].to_string());
    image_name.push_str(", ");
    image_name.push_str(&packet_params[1].to_string());
    image_name.push_str(", ");
    image_name.push_str(&packet_params[2].to_string());
    image_name.push_str("] (mV)");
    let root_drawing_area = root_drawing_area.titled(&image_name, ("sans-serif", 30).into_font()).unwrap();
    let (left, right) = root_drawing_area.split_horizontally(IMAGE_WIDTH/2);

    // build left graph context
    let mut ctx = ChartBuilder::on(&left)
        .caption("Current and Power as a Function of Voltage", ("Arial", 20))
        .x_label_area_size(40)
        .y_label_area_size(50)
        .margin(5)
        .build_ranged(0..packet_params[1] as i32, 0..7500)
        .unwrap();

    ctx.configure_mesh()
        .y_desc("Current (mA), Power (mW)")
        .x_desc("Voltage (mV)")
        .axis_desc_style(("Arial", 13))
        .draw().unwrap();
    
    // plot left graph data
    // current
    ctx.draw_series(
        series_current.iter().map(|point| TriangleMarker::new(*point, 2, &BLUE)),
    ).unwrap();
    // power
    ctx.draw_series(
        series_power.iter().map(|point| Circle::new(*point, 2, &RED)),
    ).unwrap();

    // build right graph context
    let mut ctx2 = ChartBuilder::on(&right)
        .caption("Irrad and Temp as a Function of Voltage", ("Arial", 20))
        .x_label_area_size(40)
        .y_label_area_size(50)
        .margin(5)
        .build_ranged(0..packet_params[1] as i32, 0..1100)
        .unwrap();

    ctx2.configure_mesh()
        .y_desc("Irradiance (G), Temp (C*10)")
        .x_desc("Voltage (mV)")
        .axis_desc_style(("Arial", 13))
        .draw().unwrap();
    
    // plot right graph data
    // irradiance
    ctx2.draw_series(
        series_irrad.iter().map(|point| TriangleMarker::new(*point, 2, &BLACK)),
    ).unwrap();
    // temperature
    ctx2.draw_series(
        series_temp.iter().map(|point| Circle::new(*point, 2, &GREEN)),
    ).unwrap();

    println!("[visualize] Image generated at {}.", file_path);
}